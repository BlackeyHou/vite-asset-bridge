pragma soliditypp ^0.4.5;
pragma experimental ABIEncoderV2;

contract MultiSigKeeper {
	mapping(address => bool) keepers;
	mapping(bytes32 => mapping(address => bool)) signed;
	mapping(bytes32 => uint8) signedCnt;
	// 0: pending , 1: success ing, 2: success, 3: error ing  4: error
	mapping(bytes32 => uint8) status;

	uint8 threshold;

	address vault;

	uint256 nonce;

	tokenId tid;

	bytes32 salt;

	bytes32 prevId;


	message input(address src, address dest, uint256 value);
	
	onMessage submitInput(bytes32 id, address dest, uint256 value)  {
		bool success = sigInput(id,dest,value,1);
		if(!success) {
			return;
		}
		status[id] = 2;
		send(vault,input(id, dest, value), tid, value);
		prevId = id;
	}

	onMessage errorInput(bytes32 id, address dest, uint256 value){
		bool success = sigInput(id,dest,value,3);
		if(!success) {
			return;
		}
		status[id] = 4;
		// vault.input(srcId, dest, value);
		prevId = id;
	}

	function sigInput(bytes32 id, address dest, uint256 amount, uint8 ing) internal returns(bool){
		require(keepers[msg.sender], "required keeper");
		require(id==keccak256(abi.encodePacked(salt, dest, amount, prevId)), "reqired srcId");
		uint8 cnt = signedCnt[id];
		
		require(status[id] == 0 || status[id]==ing, "required status");
		require(signed[id][msg.sender] == false, "reqired signed");

		signed[id][msg.sender] = true;
		signedCnt[id] = cnt + 1;
		if(cnt==0){
			require(status[id] == 0, "required status");
			status[id] = ing;
		}else{
			require(status[id] == ing, "required status");
		}

		if(signedCnt[id] < threshold){
			return false;
		}else{
			return true;
		}
	}

	onMessage confirmOutput(bytes calldata signature) {
		 
	}

}











